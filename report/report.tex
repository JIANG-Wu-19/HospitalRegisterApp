\documentclass[UTF8,12pt]{article}
\usepackage{ctex}
\usepackage{indentfirst}
\usepackage{color}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{subfigure}
\usepackage{pdfpages}
\usepackage{listings}
\usepackage{afterpage}
\usepackage{geometry}

\geometry{a4paper,scale=0.8}

\newcommand\myemptypage{
    \null
    \thispagestyle{empty}
    \addtocounter{page}{-1}
    \newpage
}

\hypersetup{
    hidelinks,
	colorlinks=true,
	allcolors=black,
	pdfstartview=Fit,
	breaklinks=true
}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{ %
  language=Octave,                % the language of the code
  basicstyle=\footnotesize,           % the size of the fonts that are used for the code
  numbers=left,                   % where to put the line-numbers
  numberstyle=\tiny\color{gray},  % the style that is used for the line-numbers
  stepnumber=2,                   % the step between two line-numbers. If it's 1, each line 
                                  % will be numbered
  numbersep=5pt,                  % how far the line-numbers are from the code
  backgroundcolor=\color{white},      % choose the background color. You must add \usepackage{color}
  showspaces=false,               % show spaces adding particular underscores
  showstringspaces=false,         % underline spaces within strings
  showtabs=false,                 % show tabs within strings adding particular underscores
  frame=single,                   % adds a frame around the code
  rulecolor=\color{black},        % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. commens (green here))
  tabsize=2,                      % sets default tabsize to 2 spaces
  captionpos=b,                   % sets the caption-position to bottom
  breaklines=true,                % sets automatic line breaking
  breakatwhitespace=false,        % sets if automatic breaks should only happen at whitespace
  title=\lstname,                   % show the filename of files included with \lstinputlisting;
                                  % also try caption instead of title
  keywordstyle=\color{blue},          % keyword style
  commentstyle=\color{dkgreen},       % comment style
  stringstyle=\color{mauve},         % string literal style
  escapeinside={\%*}{*)},            % if you want to add LaTeX within your code
  morekeywords={*,...}               % if you want to add more keywords to the set
}


\setlength{\parindent}{2em}

\begin{document}

\begin{titlepage}
    \includepdf[pages={1}]{cover.pdf}
\end{titlepage}

\myemptypage

\begin{center}
    \tableofcontents
\end{center}

\newpage

\section{问题描述}
\subsection{实践目的}
通过指导学生上机实践，让学生学会综合运用所学过的《计算机程序设计基础》、《数据结构》、《算法》、《Java语言与系统设计》、《数据库》、《Web技术》、《移动应用开发》等课程的基础知识，从而能够熟练掌握开发市面上比较流行的移动应用开发的基本技能，设计和开发出具有一定规模的Android客户端应用+JSP（PHP）服务器端编程+MySQL数据库的典型移动互联网应用。

\subsection{课程设计的基本要求}
\begin{itemize}
    \item 知识：了解HTML、HTML5、CSS、JavaScript、JSP、Android等开发技术在实际移动互联网应用开发过程中的基本用法；
    了解移动互联网应用开发从需求分析、系统设计、模块设计、开发以及调试的各个环节。
    掌握典型移动互联网应用各个环节的技术以及具体运用方式；
    了解移动互联网典型应用开发是如何结合Web相关技术（HTML、HTML5、CSS、JavaScript、JSP等）、移动客户端开发技术（Android为例）以及数据库技术（以MySQL为例）进行开发的。
    \item 能力：通过从无到有动手完成基于Web+Android+MySQL移动应用开发的案例的设计、编码和调试工作，将对移动互联网应用开发的理性认识转变为感性认识，
    初步体会和理解计算机相关学科的软件项目工程的具体概念，体会工程的复杂性；学会将理论知识与实际生产结合，学会用工程的角度去提出问题、分析问题和解决问题；
    初步建立移动互联网应用软件工程开发项目需求分析、总体设计、模块设计、编码实现和调试的完整概念，提高实际动手能力，
    为具备大型移动互联网应用开发软件系统从设计到开发的能力打下坚实基础。
    \item 素质：通过实际动手设计和开发多个完整的移动互联网应用实例，培养理论知识的综合运用能力和动手编程开发的能力，培养软件工程开发的流程化管理观念；在实习中理解并遵守软件工程开发的职业道德和规范，履行责任，提高职业规范素质。
\end{itemize}

\subsection{项目基本内容与要求}
\begin{enumerate}
    \item 用Android开发看病预约客户端
    \item 用JSP或PHP开发预约挂号Web服务器的后台数据库
    \item 用MySQL做预约挂号Web服务器的后台数据库
    \item 可以预约挂号、查看医生介绍及日程安排列表等功能
    \item 可以实现患者注册、登录功能
    \item 在线挂号支付
\end{enumerate}

\section{需求分析}
\subsection{开发环境}
\begin{itemize}
    \item 数据库
    \\集成环境：Navicat Premium 16
    \\MySQL 5.7.31
    \item Web服务器
    \\集成环境：Intellij IDEA 2023.1.4
    \\JDK 17.0.4.1
    \\Tomcat 9.0.55
    \\Servlet
    \item Android客户端
    \\集成环境：Android Studio 2022.3.1
    \\Android SDK 31.0.0
    \item 后台管理系统
    \\JSP
    \\LayUI
\end{itemize}

\subsection{用例分析}
本应用作为医院的看病预约应用

主要的actor是患者


主要的use case包括以下几个：
\begin{itemize}
    \item 患者注册
    \item 患者登录
    \item 患者预约挂号
    \begin{itemize}
        \item 患者选择科室
        \item 患者选择医生
        \item 患者选择预约时间
        \item 患者在线支付
        \item 患者查看医生介绍
    \end{itemize}
    \item 患者查看自己的预约挂号
\end{itemize}

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.9\textwidth]{imgs/1.png}
    \caption{看病预约应用用例图}
\end{figure}

\newpage

\section{设计思想}
设计采用前后端分离的思想，即前端使用Android客户端，后端使用Tomcat服务器，后台管理系统使用layui编写，数据持久化使用MySQL分表存储所有数据。

前端只负责与用户进行交互，后端负责处理用户的请求、验证并返回数据，同时后端负责对数据库的操作，包括表中记录的增删查改。前端不存储数据，减少了用户端的存储空间，减少了用户端的开发难度，同时保证了数据的安全性。

\begin{figure}[htbp]
    \centering
    \includegraphics[width=1.0\textwidth]{imgs/15.png}
    \caption{前后端分离架构图}
\end{figure}

\newpage

\section{概要设计}

\subsection{数据库概要设计}
新建数据库并命名为hospital，数据库的结构如下

\begin{lstlisting}[frame=shadowbox]
+--------------------+
| Tables_in_hospital |
+--------------------+
| administrator      |
| depart             |
| doctor             |
| myorder            |
| schedule           |
| user               |
+--------------------+
\end{lstlisting}

六个表中的作用如下：

\begin{itemize}
    \item user表：存储用户相关信息
    \item depart表：存储科室相关信息
    \item doctor表：存储医生相关信息
    \item schedule表：存储医生的排班信息
    \item myorder表：存储用户的预约挂号信息
    \item admistrator表：存储管理员信息
\end{itemize}

\subsection{Android看病预约客户端概要设计}
包括以下几个界面：
\begin{itemize}
    \item 启动界面
    \item 登录界面
    \item 注册界面
    \item 用户首页
    \item 科室列表
    \item 医生列表
    \item 排班时间选择
    \item 我的预约
\end{itemize}

\subsection{后台管理系统概要设计}
包括以下几个界面：
\begin{itemize}
    \item 登录界面
    \item 医生管理
    \item 排班管理
    \item 预约管理
\end{itemize}

\newpage

\section{详细设计}

\subsection{数据库详细设计}

\subsubsection{user表}
user表的主要字段有uid，uname，upsw，分别代表用户id，用户名，密码

\begin{figure}[htbp]
    \centering
    \includegraphics[width=1.0\textwidth]{imgs/5.png}
    \caption{user表}
\end{figure}

设计出的table结构如下

\begin{lstlisting}[frame=shadowbox]
+-------+--------------+------+-----+---------+-------+
| Field | Type         | Null | Key | Default | Extra |
+-------+--------------+------+-----+---------+-------+
| uid   | int(11)      | NO   | PRI | NULL    |       |
| uname | varchar(255) | NO   |     | NULL    |       |
| upsw  | varchar(255) | NO   |     | NULL    |       |
+-------+--------------+------+-----+---------+-------+
\end{lstlisting}

\newpage

\subsubsection{doctor表}

doctor表的主要字段有did，dname，dlevel，dinfo，departid，sex，ddetail分别代表医生id，医生姓名，医生职级，医生简介，医生所属科室id，医生性别，医生详细信息

\begin{figure}[htbp]
    \centering
    \includegraphics[width=1.0\textwidth]{imgs/6.png}
    \caption{doctor表}
\end{figure}

设计出的table结构如下

\begin{lstlisting}[frame=shadowbox]
+----------+--------------+------+-----+---------+-------+
| Field    | Type         | Null | Key | Default | Extra |
+----------+--------------+------+-----+---------+-------+
| did      | int(11)      | NO   | PRI | NULL    |       |
| dname    | varchar(255) | NO   |     | NULL    |       |
| dlevel   | varchar(255) | NO   |     | NULL    |       |
| dinfo    | varchar(255) | NO   |     | NULL    |       |
| departid | varchar(255) | NO   |     | NULL    |       |
| sex      | int(11)      | NO   |     | NULL    |       |
| ddetail  | varchar(255) | NO   |     | NULL    |       |
+----------+--------------+------+-----+---------+-------+
\end{lstlisting}

\newpage

\subsubsection{depart表}

depart表的主要字段有departid，departname，分别代表科室id，科室名称

\begin{figure}[htbp]
    \centering
    \includegraphics[width=1.0\textwidth]{imgs/7.png}
    \caption{depart表}
\end{figure}

设计出的table结构如下

\begin{lstlisting}[frame=shadowbox]
+------------+--------------+------+-----+---------+-------+
| Field      | Type         | Null | Key | Default | Extra |
+------------+--------------+------+-----+---------+-------+
| departid   | varchar(255) | NO   | PRI | NULL    |       |
| departname | varchar(255) | NO   |     | NULL    |       |
+------------+--------------+------+-----+---------+-------+
\end{lstlisting}

\newpage

\subsubsection{schedule表}

schedule表的主要字段有sid，did，time，price分别代表排班id，医生id，排班时间，挂号费

\begin{figure}[htbp]
    \centering
    \includegraphics[width=1.0\textwidth]{imgs/8.png}
    \caption{schedule表}
\end{figure}

设计出的table结构如下

\begin{lstlisting}[frame=shadowbox]
+-------+----------------+------+-----+---------+-------+
| Field | Type           | Null | Key | Default | Extra |
+-------+----------------+------+-----+---------+-------+
| sid   | int(11)        | NO   | PRI | NULL    |       |
| did   | int(11)        | NO   |     | NULL    |       |
| time  | varbinary(255) | NO   |     | NULL    |       |
| price | float          | NO   |     | NULL    |       |
+-------+----------------+------+-----+---------+-------+
\end{lstlisting}

\newpage

\subsubsection{myorder表}

myorder表的主要字段有oid，sid，did，分别代表订单id，排班id，医生id

\begin{figure}[htbp]
    \centering
    \includegraphics[width=1.0\textwidth]{imgs/9.png}
    \caption{myorder表}
\end{figure}

\begin{lstlisting}[frame=shadowbox]
+-------+--------------+------+-----+---------+-------+
| Field | Type         | Null | Key | Default | Extra |
+-------+--------------+------+-----+---------+-------+
| oid   | varchar(255) | NO   | PRI | NULL    |       |
| sid   | int(11)      | NO   |     | NULL    |       |
| uid   | int(11)      | NO   |     | NULL    |       |
+-------+--------------+------+-----+---------+-------+
\end{lstlisting}

\subsubsection{administrator表}
\begin{lstlisting}[frame=shadowbox]
+----------+--------------+------+-----+---------+-------+
| Field    | Type         | Null | Key | Default | Extra |
+----------+--------------+------+-----+---------+-------+
| user     | varchar(255) | NO   |     | NULL    |       |
| password | varchar(255) | NO   |     | NULL    |       |
+----------+--------------+------+-----+---------+-------+
\end{lstlisting}

\newpage

\subsection{Android看病预约客户端界面设计}
\subsubsection{界面设计流程图}
\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.65\textwidth]{imgs/3.png}
    \caption{Android看病预约客户端界面设计流程图}
\end{figure}

\newpage

\subsubsection{启动界面}
在程序启动的时候，需要一个启动界面，用于展示程序的logo，同时在启动界面中进行一些初始化操作，设置3s自动关闭启动界面。启动界面并不需要做的很复杂，只需要设计一个背景，然后添加一个按钮用于跳过启动界面即可。

设计的XML代码如下：

\begin{lstlisting}
<?xml version="1.0" encoding="utf-8"?>
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context=".ui.activity.SplashActivity"
    android:background="@mipmap/splashbg">
    <Button
        android:id="@+id/id_btn_skip"
        android:layout_alignParentRight="true"
        android:layout_alignParentTop="true"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="right"
        android:layout_marginRight="32dp"
        android:layout_marginTop="32dp"
        android:background="@drawable/btn_bg_skip"
        android:paddingBottom="4dp"
        android:paddingLeft="12dp"
        android:paddingRight="12dp"
        android:paddingTop="4dp"
        android:text="跳过"
        android:minWidth="0dp"
        android:minHeight="0dp"
        android:textColor="#ffffff"
        android:textSize="14sp" />
</RelativeLayout>
\end{lstlisting}

\newpage

界面效果如下：

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.6\textwidth]{imgs/10.png}
    \caption{启动界面}
\end{figure}

\subsubsection{登录界面}
登录界面需要设计一个背景，然后添加一个logo，接着添加两个输入框，分别用于输入用户名和密码，最后添加一个登录按钮。需要注意的是，在登录界面需要额外设置一个按钮，用于跳转到注册界面。
\begin{lstlisting}
<?xml version="1.0" encoding="utf-8"?>
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context=".ui.activity.LoginActivity"
    android:background="@mipmap/login_bg">
    <TextView
        android:id="@+id/id_tv_title"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_centerHorizontal="true"
        android:layout_marginTop="90dp"
        android:text="掌上医院"
        android:textSize="40sp"
        android:textStyle="bold"></TextView>
    <EditText
        android:paddingLeft="20dp"
        android:id="@+id/id_et_uid"
        android:layout_width="match_parent"
        android:layout_height="56dp"
        android:layout_below="@id/id_tv_title"
        android:layout_marginTop="40dp"
        android:background="#44ffffff"
        android:hint="请输入账号"
        android:inputType="text"
        android:textColorHint="#070707" />
    <EditText
        android:paddingLeft="20dp"
        android:id="@+id/id_et_upsw"
        android:layout_width="match_parent"
        android:layout_height="56dp"
        android:layout_below="@id/id_et_uid"
        android:layout_marginTop="4dp"
        android:background="#44ffffff"
        android:hint="请输入密码"
        android:inputType="textWebPassword"
        android:textColorHint="#070707" />
    <Button
        android:id="@+id/id_btn_login"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:layout_below="@id/id_et_upsw"
        android:layout_marginLeft="60dp"
        android:layout_marginTop="50dp"
        android:layout_marginRight="60dp"
        android:background="#87CEFA"
        android:text="登录"
        android:textSize="26sp" />
    <TextView
        android:id="@+id/id_tv_register"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_below="@id/id_btn_login"
        android:layout_centerHorizontal="true"
        android:layout_marginTop="30dp"
        android:text="注册账号"
        android:textSize="18sp"
        android:textColor="#000000" />
</RelativeLayout>
\end{lstlisting}

以上是登录界面的XML代码，界面效果如下：

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.4\textwidth]{imgs/11.png}
    \caption{登录界面}
\end{figure}

\subsubsection{注册界面}
注册界面需要设计一个背景，然后添加一个logo，接着添加四个输入框，分别用于输入用户姓名、用户名、密码、重复密码，最后添加一个注册按钮。需要注意的是，在注册界面需要额外设置一个按钮，用于跳转到登录界面。

这里的XML源码比较长，不进行展示，界面效果如下：

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.4\textwidth]{imgs/12.png}
    \caption{注册界面}
\end{figure}

\subsubsection{用户首页}
用户首页设置一个背景，然后添加一个logo，接着添加三个按钮，分别用于跳转到预约挂号、我的信息、退出登录。目前只对用户首页进行了简单设计，并没有添加美化内容，只展示一个原型界面

实现的XML代码如下：

\begin{lstlisting}
    <?xml version="1.0" encoding="utf-8"?>
    <LinearLayout
        xmlns:android="http://schemas.android.com/apk/res/android"
        xmlns:app="http://schemas.android.com/apk/res-auto"
        xmlns:tools="http://schemas.android.com/tools"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:orientation="vertical"
        tools:context=".ui.activity.IndexActivity"
        android:background="@mipmap/login_bg"
        >
        <TextView
            android:id="@+id/welcome_uname"
            android:layout_marginTop="30dp"
            android:layout_width="match_parent"
            android:layout_height="50dp"
            android:text="李明，欢迎您！"
            android:gravity="center"
            android:textSize="26sp"
            android:textColor="@color/black"
            ></TextView>
        <Button
            android:id="@+id/btn1"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="预约挂号"
            android:layout_marginTop="30dp"
            android:layout_marginLeft="20dp"
            android:layout_marginRight="20dp"
            android:textSize="26sp"
            android:background="#87CEFA"
            />
        <Button
            android:id="@+id/btn2"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="我的信息"
            android:layout_marginTop="50dp"
            android:layout_marginLeft="20dp"
            android:layout_marginRight="20dp"
            android:textSize="26sp"
            android:background="#87CEFA"/>
        <Button
            android:id="@+id/btn3"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="退出账号"
            android:layout_marginTop="50dp"
            android:layout_marginLeft="20dp"
            android:layout_marginRight="20dp"
            android:textSize="26sp"
            android:background="#87CEFA"/>
    </LinearLayout>
\end{lstlisting}

界面效果如下：

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.4\textwidth]{imgs/13.png}
    \caption{用户首页}
\end{figure}

用户在预约挂号时，展现的科室列表、医生列表实际是一致的，在顶部标题处作区分，这里只展示科室列表设计。

\subsubsection{科室列表}
科室列表是一个列表，需要设计一个背景，然后添加一个logo，接着添加一个列表，用于展示科室列表

实现的XML代码如下：

\newpage

\begin{lstlisting}
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context=".ui.activity.ChooseDepartActivity"
    android:orientation="vertical">
    <LinearLayout
        android:layout_width="wrap_content"
        android:layout_height="40dp">
        <ImageView
            android:id="@+id/btn_back"
            android:layout_width="40dp"
            android:layout_height="40dp"
            android:src="@mipmap/btn_back"></ImageView>
    </LinearLayout>
    <ListView
        android:id="@+id/depart_list_view"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:layout_marginLeft="20dp"
        android:layout_marginRight="20dp"></ListView>
</LinearLayout>
\end{lstlisting}

在列表的顶部作区分，部门、医生列表的顶部没有特殊设计，排班时间选择的时候，顶部打印了当前选择的医生信息。

\newpage

\subsection{Android看病预约客户端操作实现}
\subsubsection{启动界面}
用户点击软件图标之后，先进入启动页面，展示图标和软件名称，然后跳转到登录界面，右上角有一个跳过按钮，点击之后直接跳转到主界面。

实现activity为SplashActivity，点击“跳过”时，直接跳转到登录页面，具体如下：

\begin{lstlisting}[frame=shadowbox]
    public class SplashActivity extends AppCompatActivity {
    private Handler mHandler = new Handler();
    private Button mBtnSkip;
    private Runnable mRunnableToMain = new Runnable() {
        @Override
        public void run() {
            toLoginActivity();
        }
    };

    private void toLoginActivity() {
        Intent intent = new Intent(this, LoginActivity.class);
        startActivity(intent);
        finish();
    }

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_splash);

        mBtnSkip = (Button) findViewById(R.id.id_btn_skip);
        mHandler.postDelayed(mRunnableToMain, 3000);

        mBtnSkip.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                mHandler.removeCallbacks(mRunnableToMain);
                toLoginActivity();
            }
        });

    }
}

\end{lstlisting}

\subsubsection{登录/注册界面}
用户经过启动页面之后，进入登录页面，用户根据自身需求选择：跳转到注册界面，或直接输入账号密码进行登录。

若跳转到注册界面，用户输入账号密码，点击注册按钮，将账号密码发送到服务器，服务器返回注册成功或失败的信息，若成功，则跳转到登录界面，若失败，则提示用户注册失败。

若直接登录，则用户输入账号密码，点击登录按钮，将账号密码发送到服务器，服务器返回登录成功或失败的信息，若成功，则跳转到主界面，若失败，则提示用户登录失败。

具体的流程图如下：

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.6\textwidth]{imgs/14.png}
    \caption{登录/注册流程图}
\end{figure}

\newpage

在应用端只负责提交数据，不负责验证数据，验证数据的工作交给服务器端，也就是说应用端只需要提取输入框的输入即可，返回的提示用toast实现，具体代码如下：

\begin{lstlisting}[frame=shadowbox]
    public String requestDataByPost(String urlString) {
        String result = null;
        try {
            URL url = new URL(urlString);
            HttpURLConnection connection = (HttpURLConnection) url.openConnection();
            connection.setConnectTimeout(30000);
            connection.setRequestMethod("POST");

            // 设置运行输入,输出:
            connection.setDoOutput(true);
            connection.setDoInput(true);
            // Post方式不能缓存,需手动设置为false
            connection.setUseCaches(false);
            connection.connect();

            // 我们请求的数据:
            String data = "uid=" + URLEncoder.encode(uid, "UTF-8")
                    + "&upsw=" + URLEncoder.encode(upsw, "UTF-8");
            // 获取输出流
            OutputStream out = connection.getOutputStream();
            out.write(data.getBytes());
            out.flush();
            out.close();

            int responseCode = connection.getResponseCode();
            if (responseCode == HttpURLConnection.HTTP_OK) {
                InputStream inputStream = connection.getInputStream();
                result = NetUtil.streamToString(inputStream);

                user = new Gson().fromJson(result,User.class);


            } else {
                String responseMessage = connection.getResponseMessage();

            }


            connection.disconnect();
            return result;
        } catch (MalformedURLException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
        return null;
    }
\end{lstlisting}

注册与登录类似，唯一不同的是请求的数据不同，注册需要提交的数据有uid，upsw，uname，而登录只需要提交uid，upsw即可。

\begin{lstlisting}[frame=shadowbox]
    String data ="uname=" + URLEncoder.encode(uname, "UTF-8") +  "&uid=" + URLEncoder.encode(uid, "UTF-8")
    + "&upsw=" + URLEncoder.encode(upsw, "UTF-8");
\end{lstlisting}

\subsubsection{预约界面}
预约分为三步
\begin{enumerate}
    \item 选择科室
    \item 选择医生
    \begin{itemize}
        \item 查看医生详细介绍
    \end{itemize}
    \item 选择时间
\end{enumerate}

\textbf{选择科室}

向后端请求科室数据，获取科室List，然后将科室List展示在列表中，用户点击列表中的某一项，跳转到医生列表界面，同时将用户选择的科室信息传递到医生列表界面，用于向后端请求医生列表数据。

实现方法如下：

\begin{lstlisting}[frame=shadowbox]
    public class DepartListAdapter extends BaseAdapter{
        private List<Depart> mdeparts;
        DepartListAdapter(List<Depart> departs){
            mdeparts = departs;
        }
        @Override
        public int getCount() {
            return mdeparts.size();
        }

        @Override
        public Object getItem(int i) {
            return mdeparts.get(i);
        }

        @Override
        public long getItemId(int i) {
            return mdeparts.get(i).getDepartid();
        }

        @Override
        public View getView(int i, View view, ViewGroup viewGroup) {

            if(view == null){
                LayoutInflater layoutInflater = (LayoutInflater)getSystemService(Context.LAYOUT_INFLATER_SERVICE);
                view = layoutInflater.inflate(R.layout.item_depart_list_view,null);
            }
            TextView departName = view.findViewById(R.id.depart_name_tv);
            departName.setText(mdeparts.get(i).getDepartname());

            departName.setOnClickListener(new View.OnClickListener() {
                @Override
                public void onClick(View view) {
                    Intent intent = new Intent(ChooseDepartActivity.this,ChooseDoctorActivity.class);
                    intent.putExtra("depart",new Gson().toJson(mdeparts.get(i)));
                    startActivity(intent);


                }
            });

            return view;
        }
    }
\end{lstlisting}

\textbf{选择医生}

向后端请求医生数据，获取医生List，然后将医生List展示在列表中，用户点击列表中的某一项，跳转到排班时间选择界面，同时将用户选择的医生信息传递到排班时间选择界面，用于向后端请求排班时间数据。

实现方法如下：

\begin{lstlisting}[frame=shadowbox]
    public class DoctorListAdapter extends BaseAdapter {
        private List<Doctor> mdoctors;
        DoctorListAdapter(List<Doctor> doctors){
            mdoctors = doctors;
        }
        @Override
        public int getCount() {
            return mdoctors.size();
        }

        @Override
        public Object getItem(int i) {
            return mdoctors.get(i);
        }

        @Override
        public long getItemId(int i) {
            return mdoctors.get(i).getDid();
        }

        @Override
        public View getView(int i, View view, ViewGroup viewGroup) {

            if(view == null){
                LayoutInflater layoutInflater = (LayoutInflater)getSystemService(Context.LAYOUT_INFLATER_SERVICE);
                view = layoutInflater.inflate(R.layout.item_doctor_list_view,null);
            }
            ImageView dimg = view.findViewById(R.id.dimg);
            TextView dname = view.findViewById(R.id.dname);
            TextView dlevel = view.findViewById(R.id.dlevel);
            TextView dinfo = view.findViewById(R.id.dinfo);

            LinearLayout btn_ddetail = view.findViewById(R.id.btn_ddetail);
            Button btn_reverse = view.findViewById(R.id.btn_reverse);


            if(mdoctors.get(i).getSex()==1){
                dimg.setImageResource(R.mipmap.doctor_male);
            }
            else{
                dimg.setImageResource(R.mipmap.doctor_female);
            }
            dname.setText(mdoctors.get(i).getDname());
            dlevel.setText(mdoctors.get(i).getDlevel());
            dinfo.setText(mdoctors.get(i).getDinfo());


            btn_ddetail.setOnClickListener(new View.OnClickListener(){
                @Override
                public void onClick(View view) {
                    Intent intent = new Intent(ChooseDoctorActivity.this,DoctorDetailActivity.class);
                    intent.putExtra("doctor",new Gson().toJson(mdoctors.get(i)));
                    startActivity(intent);
                }
            });

            btn_reverse.setOnClickListener(new View.OnClickListener() {
                @Override
                public void onClick(View view) {
                    Intent intent = new Intent(ChooseDoctorActivity.this,ChooseTimeActivity.class);
                    intent.putExtra("doctor",new Gson().toJson(mdoctors.get(i)));
                    startActivity(intent);
                }
            });

            return view;
        }
    }
\end{lstlisting}

\textbf{医生详细介绍}

医生详细介绍界面只是简单的展示医生的详细介绍，没有其他操作，只需要获取医生的数据，然后展示即可。

\begin{lstlisting}[frame=shadowbox]
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_doctor_detail);
        String doctorJson = getIntent().getStringExtra("doctor");
        doctor =  new Gson().fromJson(doctorJson, Doctor.class);
        Log.e("DoctorDetailActivity","传来的数据："+ doctor);
        ImageView dimg = findViewById(R.id.dimg);
        TextView dname = findViewById(R.id.dname);
        TextView dlevel = findViewById(R.id.dlevel);
        TextView dinfo = findViewById(R.id.dinfo);
        TextView ddetail = findViewById(R.id.ddetail);
        if(doctor.getSex()==1){
            dimg.setImageResource(R.mipmap.doctor_male);
        }
        else{
            dimg.setImageResource(R.mipmap.doctor_female);
        }
        dname.setText(doctor.getDname());
        dlevel.setText(doctor.getDlevel());
        dinfo.setText(doctor.getDinfo());
        ddetail.setText(doctor.getDdetail());

        ImageView btn_back = findViewById(R.id.btn_back);
        btn_back.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                Intent intent = new Intent(DoctorDetailActivity.this,ChooseDoctorActivity.class);
                intent.putExtra("departid",doctor.getDdepartid());
                startActivity(intent);
            }
        });
    }
\end{lstlisting}

\textbf{选择时间}

根据选择的医生，向后端请求排班时间数据，获取排班时间List，然后将排班时间List展示在列表中，用户点击列表中的某一项，跳转到支付界面，同时将用户选择的排班时间信息传递到支付界面，用于向后端请求支付数据。实际的获取列表方式和前面一致，修改传入参数就可以了。

\subsubsection{支付界面}
支付界面展示之前的选择结果，设置两个按钮监听器，一个用于支付，一个用于取消支付，点击支付按钮，向后端请求支付数据，获取支付数据，然后调用支付接口，调用成功则提示用户支付成功，调用失败则提示用户支付失败，点击取消支付按钮，直接跳转到用户首页。

这里看一下两个按钮的监听器，支付按钮的监听器如下：

\begin{lstlisting}[frame=shadowbox]
    pay_yes.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                baseurl += "?sid="+schedule.getSid()+"&uid="+user.getUid();
                Toast.makeText(getBaseContext(),"预约挂号成功！",Toast.LENGTH_SHORT).show();
                new PayActivity.PayAsyncTask().execute();

            }
        });
\end{lstlisting}

取消支付按钮的监听器如下：

\begin{lstlisting}[frame=shadowbox]
    pay_no.setOnClickListener(new View.OnClickListener() {
        @Override
        public void onClick(View view) {
            Toast.makeText(getBaseContext(),"预约挂号取消成功！",Toast.LENGTH_SHORT).show();
            Intent intent = new Intent(PayActivity.this,ChooseTimeActivity.class);
            intent.putExtra("doctor",new Gson().toJson(doctor));
            startActivity(intent);
        }
    });
\end{lstlisting}

\newpage

\subsubsection{我的信息界面}
主要用于显示已经预约的结果，向后端请求预约数据，获取预约数据，然后将预约数据展示在列表中，用户点击列表中的某一项，跳转到预约详情界面，同时将用户选择的预约信息传递到预约详情界面，用于展示预约详情。

\begin{lstlisting}[frame=shadowbox]
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_my_info);
        user =  new Gson().fromJson( getIntent().getStringExtra("user"), User.class);
        TextView uname = findViewById(R.id.welcome_uname);
        ImageView btn_back = findViewById(R.id.btn_back);
        myInfoListView = findViewById(R.id.myinfo_list_view);
        btn_back.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                Intent intent = new Intent(MyInfoActivity.this,IndexActivity.class);
                intent.putExtra("user",new Gson().toJson(user));
                startActivity(intent);
            }
        });
        if(user!=null){
            uname.setText(""  + user.getUname() + "，欢迎您！");
        }
        baseurl= baseurl + "?uid="+user.getUid();
        new MyInfoActivity.MyinfoAsyncTask().execute();
    }
\end{lstlisting}

\newpage

\subsection{配置android网络}
android 和web 服务器的数据交互，涉及到android 的网络相关操作，可以选择使用第三方库或者自己编写简单的代码实现。我采用了自己编写代码，并抽取到工具类NetUtil中。

\subsubsection{配置baseurl}
首先配置类Config，里面存储了访问服务器用的url中基础的部分，本实践采用了主机作服务器，其中由于主机连接WLAN，而非有线的Ethernet，因此ip地址会变化；对于实际的工程来说，服务器的ip应当是固定的，不存在以上问题。

\begin{lstlisting}[frame=shadowbox]
    public class Config {
        public static String baseUrl ="http://100.67.123.30:8080/PalmHospitalService_war_exploded/";
    }
\end{lstlisting}

这样在其他类中，只需要将url加上这一部分，修改代码很方便。

\subsubsection{编写工具类NetUtil}
接着编写工具类NetUtil：由于数据量不大，我们都采用Get 的请求方式，将参数添加在url 末尾。编写函数requestDataByGet：参数url，进行HttpURLConnection 的相关设置，获取请求的返回码，判断是否成功等等

\begin{lstlisting}[frame=shadowbox]
    package com.example.palmhospital.utils;

    import android.util.Log;
    import java.io.ByteArrayOutputStream;
    import java.io.IOException;
    import java.io.InputStream;
    import java.net.HttpURLConnection;
    import java.net.MalformedURLException;
    import java.net.URL;
    public class NetUtil {
        public static String requestDataByGet(String urlString) {
            String result = null;
            try {
                URL url = new URL(urlString);
                HttpURLConnection connection = (HttpURLConnection) url.openConnection();
                connection.setConnectTimeout(30000);        // 设置超时时间
                connection.setRequestMethod("GET");  // 请求的方法类型：GET POST
                connection.setRequestProperty("Content-Type", "application/json");      // 获取到的数据格式
                connection.setRequestProperty("Charset", "UTF-8");
                connection.setRequestProperty("Accept-Charset", "UTF-8");
                connection.connect();       // 发起连接
                int responseCode = connection.getResponseCode();    // 获取请求的返回码
                if (responseCode == HttpURLConnection.HTTP_OK) {        // 返回码是200，成功
                    InputStream inputStream = connection.getInputStream();
                    result = streamToString(inputStream);
                } else {
                    String responseMessage = connection.getResponseMessage();
                    //Log.e(TAG, "requestDataByPost: " + responseMessage);
                }
            } catch (MalformedURLException e) {
                e.printStackTrace();
            } catch (IOException e) {
                e.printStackTrace();
            }
            return result;
        }
        public static String streamToString(InputStream is) {
            try {
                ByteArrayOutputStream baos = new ByteArrayOutputStream();
                byte[] buffer = new byte[1024];
                int len;
                while ((len = is.read(buffer)) != -1) {
                    baos.write(buffer, 0, len);
                }
                baos.close();
                is.close();
                byte[] byteArray = baos.toByteArray();
                return new String(byteArray);
            } catch (Exception e) {
                Log.e("LoginActivity", e.toString());
                return null;
            }
        }
    }    
\end{lstlisting}

\newpage

\subsection{后台管理系统前端详细设计}
后台管理系统设计较为简便只需要设计一个登录/注册界面，一个控制台界面即可，控制台界面中用iframe标签嵌入其他页面，实现页面的跳转。

包括以下jsp文件：

\begin{itemize}
    \item login.jsp 
    \item register.jsp
    \item controller.jsp
    \item orders.jsp
    \item schedules.jsp
    \item doctors.jsp
\end{itemize}

比较需要关注的点是访问控制台界面的前置条件是登录了管理员的账号，也就是说，如果没有登录，是不能访问控制台界面的，因此需要在访问控制台界面的时候，判断是否登录，如果没有登录，则跳转到登录界面。

在controller.jsp中以及其他嵌入的标签页中，都需要判断是否登录，如果没有登录，则跳转到登录界面。

判断代码如下：

\begin{lstlisting}[frame=shadowbox]
<%
    String user=(String) request.getSession().getAttribute("user");
    if(user==null){
        response.sendRedirect("login.jsp");
        return;
    }
%>
\end{lstlisting}

在后台登录Servlet中需要设置session

\begin{lstlisting}[frame=shadowbox]
    request.getSession().setAttribute("user",user);
\end{lstlisting}

接下来将详细介绍控制台界面的设计

\newpage

\subsubsection{controller.jsp}

\begin{figure}[htbp]
    \centering
    \includegraphics[width=1.0\textwidth]{imgs/17.png}
    \caption{控制台界面}
\end{figure}

控制台界面的设计比较简单，只需要插入三个子页面，使用iframe标签嵌入，对点击时间进行区分，点击不同的按钮，加载不同的页面，实现页面的跳转。

\begin{lstlisting}[frame=shadowbox]
    <ul class="layui-nav layui-nav-tree" lay-filter="test">
        <li class="layui-nav-item layui-nav-itemed">
            <a class="main_left" data-src="orders.jsp">预约信息管理</a>
        </li>

        <li class="layui-nav-item layui-nav-itemed">
            <a class="main_left" data-src="doctors.jsp">医生信息管理</a>
        </li>

        <li class="layui-nav-item layui-nav-itemed">
            <a class="main_left" data-src="schedules.jsp">排班信息管理</a>
        </li>
    </ul>

    ...

    <iframe id="mainframe" frameborder="0" scrolling="yes" style="width: 100%;height: 100%" src="orders.jsp"> </iframe>

    ... 

    <script>
    $(function(){
        $(".main_left").click(function(){
            var src = $(this).attr("data-src");
            $("#mainframe").attr("src",src);
        });
    });
    </script>
\end{lstlisting}

\subsubsection{orders.jsp}
在挂号预约信息界面，需要展示所有的预约信息，包括预约id，用户id，用户姓名，科室名称，医生姓名，预约时间，挂号费等字段，同时需要提供删除预约信息的功能。

\begin{figure}[htbp]
    \centering
    \includegraphics[width=1.0\textwidth]{imgs/18.png}
    \caption{预约信息管理界面}
\end{figure}

表格数据实时动态渲染，使用layui的table模块，具体代码如下：

\begin{lstlisting}[frame=shadowbox]
    table.render({
            elem: '#test',
            url: 'http://localhost:8080/PalmHospitalService_war_exploded/OrderServlet', // 此处为静态模拟数据，实际使用时需换成真实接口
            toolbar: '#toolbarDemo',
            height: 'full-200', // 最大高度减去其他容器已占有的高度差
            css: [ // 重设当前表格样式
                '.layui-table-tool-temp{padding-right: 1000px;}'
            ].join(''),
            cellMinWidth: 80,
            totalRow: false, // 开启合计行
            page: false,
            cols: [[
                {type: 'checkbox', fixed: 'left'},
                {field:'oid',width:130, title: '预约ID'},
                {field:'uid',width:130, title: '用户ID'},
                {field:'uname',width:150, title: '用户姓名'},
                {field:'time',width:300, title: '挂号时间'},
                {field:'departname',width:160, title: '科室名称'},
                {field:'dname',width:130, title: '医生姓名'},
                {field:'price',width:130, title: '挂号费用(元)'},
                {fixed: 'right', title:'操作', width: 80, minWidth: 80, toolbar: '#barDemo'}
            ]],

            ...

            error: function(res, msg){
                console.log(res, msg)
            }
        });
\end{lstlisting}

在前端界面中，对于删除处理的操作，layui原生框架提供了类似操作的封装，对表格的toolbar进行设置，即可实现删除操作，具体代码如下：

\begin{lstlisting}[frame=shadowbox]
    table.on('tool(test)', function(obj){ // 双击 toolDouble
            var data = obj.data; // 获得当前行数据
            console.log(data)
            if(obj.event === 'delete'){
                layer.confirm('确定取消预约 [预约ID: '+ data.oid +'] ', function(index){
                    const url1 = "http://localhost:8080/PalmHospitalService_war_exploded/DeleteOrdersServlet?oid=" + data.oid;
                    // 使用 Fetch API 发起 DELETE 请求
                    fetch(url1, {
                        method: 'GET',
                    })
                        .then(response => {
                            if (!response.ok) {
                                throw new Error('Network response was not ok');
                            }
                        })
                        .then(() => {
                            obj.del(); // 删除对应行（tr）的DOM结构
                        })
                        .catch(error => {
                            // 请求失败时的处理
                            console.error('There has been a problem with your fetch operation:', error);
                        });

                    // obj.del();
                    layer.close(index);
                    // 向服务端发送删除指令
                })
            }
        });
\end{lstlisting}

\newpage

\subsubsection{doctors.jsp}
在医生信息管理界面，需要展示所有的医生信息，包括医生id，医生姓名，医生职级，医生简介，医生详细信息，科室id，科室名称，医生性别等字段，同时需要提供修改医生信息的功能。

\begin{figure}[htbp]
    \centering
    \includegraphics[width=1.0\textwidth]{imgs/19.png}
    \caption{医生信息管理界面}
\end{figure}

表格数据试试动态渲染，使用layui的table模块；修改医生信息设置信息列的edit值为textarea，修改部分使用js实现，与上面的类似，这里不再赘述。

\begin{lstlisting}[frame=shadowbox]
    table.render({...
      url: 'http://localhost:8080/PalmHospitalService_war_exploded/DoctorServlet', // 此处为静态模拟数据，实际使用时需换成真实接口
      ...
      cols: [[{type: 'checkbox', fixed: 'left'},
        {field:'did',width:150, title: '医生ID',sort:true},
        {field:'departname',width:150, title: '科室名称'},
        {field:'dname',width:150, title: '医生姓名'},
        {field:'dlevel',width:150, title: '医生职称'},
        {field:'dinfo', title: '医生信息',width:300,edit: 'textarea'},
        {field:'ddetail',width:300, title: '详细信息',edit: 'textarea'},]],
        ...
    });
\end{lstlisting}

\newpage

\subsubsection{schedules.jsp}

在排班信息管理界面，需要展示所有的排班信息，包括排班id，医生id，排班时间，挂号费等字段，同时需要提供删除排班信息的功能，与预约信息管理界面类似。

\begin{figure}[htbp]
    \centering
    \includegraphics[width=1.0\textwidth]{imgs/20.png}
    \caption{排班信息管理界面}
\end{figure}

\begin{lstlisting}[frame=shadowbox]
    table.render({...
      url: 'http://localhost:8080/PalmHospitalService_war_exploded/ScheduleServlet', // 此处为静态模拟数据，实际使用时需换成真实接口
      ...
      cols: [[
        {type: 'checkbox', fixed: 'left'},
        {field:'sid',width:220, title: '排班ID', sort:true},
        {field:'dname',width:220, title: '医生姓名'},
        {field:'departname',width:220, title: '科室名称'},
        {field:'time',width:250, title: '排班时间'},
        {field:'price', title: '挂号价格',width:220},
        {fixed: 'right', title:'操作', width: 80, minWidth: 80, toolbar: '#barDemo'}
      ]],
      ...
    });
\end{lstlisting}

\newpage

\subsection{预约挂号Web服务器详细设计}
Web服务器需要处理两类业务，一类是移动端的业务，一类是后台管理的业务。那么对于上述业务，我们需要设计的包如下，设置两个包分别处理移动端和后台管理的业务。

\begin{figure}[htbp]
    \centering
    \includegraphics[width=1.0\textwidth]{imgs/16.png}
    \caption{包结构}
\end{figure}

\subsubsection{bean}
包bean用于存放实体类，包括用户、医生、科室、排班、订单等实体类，其中一部分与数据库中单表的结构一致，另一部分是为了方便处理业务而设计的。

包bean包含以下实体类：

\begin{itemize}
    \item Administrator：管理员实体类，包含管理员用户名，密码等字段
    \item BackDoctors：后端医生实体类，包含医生id，医生姓名，医生职级，医生简介，医生详细信息等字段
    \item BackOrders：后端预约实体类，包含预约id，用户id，用户姓名，科室名称，医生姓名，预约时间，挂号费等字段
    \item BackSchedules：后端排班实体类，包含排班id，医生id，排班时间，挂号费等字段
    \item Depart：科室实体类，包含科室id，科室名称等字段
    \item Doctor：医生实体类，包含医生id，医生姓名，医生职级，医生简介，医生详细信息，科室id，科室名称，医生性别等字段
    \item Order/Orders：两个不同用途的预约实体类
    \item Schedule：排班实体类，包含排班id，医生id，排班时间，挂号费等字段
    \item User：用户实体类，包含用户id，用户名，密码
\end{itemize}

\subsubsection{dao}
包dao用于存放数据访问对象，包括用户、医生、科室、排班、订单等数据访问对象，其中一部分与数据库中单表的结构一致，另一部分是为了方便处理业务而设计的。

包dao包含以下数据访问对象：

\begin{itemize}
    \item AdministratorDao：管理员数据访问对象，包含管理员用户名，密码等字段
    \item BackDoctorsDao：后端医生数据访问对象，包含医生id，医生姓名，医生职级，医生简介，医生详细信息等字段
    \item BackOrderDao：后端预约数据访问对象，包含预约id，用户id，用户姓名，科室名称，医生姓名，预约时间，挂号费等字段
    \item BackSchedulesDao：后端排班数据访问对象，包含排班id，医生id，排班时间，挂号费等字段
    \item DepartDao：科室数据访问对象，包含科室id，科室名称等字段
    \item DoctorDao：医生数据访问对象，包含医生id，医生姓名，医生职级，医生简介，医生详细信息，科室id，科室名称，医生性别等字段
    \item OrderDao：预约数据访问对象，包含预约id，用户id，用户姓名，科室名称，医生姓名，预约时间，挂号费等字段
    \item ScheduleDao：排班数据访问对象，包含排班id，医生id，排班时间，挂号费等字段
    \item UserDao：用户数据访问对象，包含用户id，用户名，密码
\end{itemize}

\subsubsection{Servlet}
包Servlet用于存放移动端数据请求处理的Servlet，包括用户、医生、科室、排班、订单等Servlet

包servlet包含以下servlet对象：

\begin{itemize}
    \item ChooseDepartServlet：选择科室Servlet，用于处理移动端选择科室的请求
    \item ChooseDoctorServlet：选择医生Servlet，用于处理移动端选择医生的请求
    \item ChooseTimeServlet：选择时间Servlet，用于处理移动端选择时间的请求
    \item LoginServlet：登录Servlet，用于处理移动端登录的请求
    \item MyInfoServlet：我的信息Servlet，用于处理移动端我的信息的请求
    \item PayServlet：支付Servlet，用于处理移动端支付的请求
    \item RegisterServlet：注册Servlet，用于处理移动端注册的请求
\end{itemize}

\subsubsection{backend}
包backend用于存放后台管理数据请求处理的Servlet，包括用户、医生、科室、排班、订单等Servlet

包backend包含以下servlet对象：

\begin{itemize}
    \item BackRegisterServlet：后台管理注册Servlet，用于处理后台管理注册的请求
    \item DeleteOrdersServlet: 删除预约Servlet，用于处理后台管理删除预约的请求
    \item DeleteSchedulesServlet：删除排班Servlet，用于处理后台管理删除排班的请求
    \item DoctorServlet: 医生Servlet，用于处理后台管理医生的请求
    \item LogoutServlet：注销Servlet，用于处理后台管理注销的请求
    \item OrderServlet：预约Servlet，用于处理后台管理预约的请求
    \item ScheduleServlet：排班Servlet，用于处理后台管理排班的请求
    \item TestServlet: 登录Servlet，用于登录，由于一开始在该class上测试及运行故没有更改名字
\end{itemize}

其中servlet/backend包中的servlet类，都继承了HttpServlet类，重写了doGet和doPost方法，用于处理get和post请求，具体的实现方法如下：

\begin{lstlisting}[frame=shadowbox]
@WebServlet(name="XXXServlet",value="/XXXServlet")
public class XXXServlet extends HttpServlet {
    public XXXServlet (){
        super();
    }

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {
        // 设置GET方法的响应内容类型
    }


    public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        // 设置POST方法的响应内容类型
        doGet(request, response);
    }
}
\end{lstlisting}

\subsubsection{utils}
里面有用于连接数据库的工具类DBUtil

\begin{lstlisting}[frame=shadowbox]
package com.example.palmhospitalservice.utils;

import com.alibaba.druid.pool.DruidDataSource;
import com.alibaba.druid.pool.DruidDataSourceFactory;
import org.apache.commons.dbutils.DbUtils;

import java.io.IOException;
import java.io.InputStream;
import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.Properties;

public class DbUtil {
    private static DruidDataSource ds;
    private static final ThreadLocal<Connection> THREAD_LOCAL = new ThreadLocal<>();

    static {
        Properties properties = new Properties();
        InputStream inputStream = DbUtils.class.getResourceAsStream("/database.properties");
        try {
            properties.load(inputStream);
            ds = (DruidDataSource) DruidDataSourceFactory.createDataSource(properties);
        } catch (IOException e) {
            e.printStackTrace();
        } catch (Exception e) {
            e.printStackTrace();
        }

    }
    public static Connection getConnection() {

        Connection connection = THREAD_LOCAL.get();

        try {
            if (connection == null) {
                connection = ds.getConnection();

                THREAD_LOCAL.set(connection);
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }


        return connection;
    }
    public static void begin() {
        Connection connection = null;
        connection = getConnection();
        try {
            connection.setAutoCommit(false);
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
    public static void commit() {
        Connection connection = null;
        try {
            connection = getConnection();
            connection.commit();
        } catch (SQLException e) {
            e.printStackTrace();
        } finally {
            closeAll(connection, null, null);
        }
    }
    public static void rollback() {
        Connection connection = null;
        try {
            connection = getConnection();
            connection.rollback();
        } catch (SQLException e) {
            e.printStackTrace();
        } finally {
            closeAll(connection, null, null);
        }
    }
    public static void closeAll(Connection connection, Statement statement, ResultSet resultSet) {
        try {
            if (resultSet != null) {
                resultSet.close();
            }
            if (statement != null) {
                statement.close();
            }
            if (connection != null) {
                connection.close();
                THREAD_LOCAL.remove();
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
}
\end{lstlisting}





\newpage

\section{调试方法}

\newpage

\section{测试结果}

\newpage

\section{心得体会}

\newpage

\section{附录}

\newpage


\end{document}